---
layout: post
title: "ÁΩëÁªúÂ∞ÅË£Ö‰∏≠ Error Â§ÑÁêÜ"
subtitle: " "
author: "Genie"
header-img: "img/ef.jpg"
header-mask: 0.7
tags:
  -  swift
---

enum ÊòØÂ∞ÅË£Ö‰∏≠‰∏Ä‰∏™Â∏∏Áî®ÁöÑÊñπÂºèÔºåenum ÂèØ‰ª•‰∏éÂÖ∂‰ªñÂÆû‰æãËøõË°åÁªëÂÆöÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•ËÆ©ÊñπÊ≥ïËøîÂõûÊûö‰∏æÁ±ªÂûã„ÄÇ

```
public struct ErrorMetaData: Codable {
    public var code: Int?
    public var msg: String?
}

public enum NetworkResponseError: Error {
    case error(errorData: ErrorMetaData)
    case parsingError(error: Error?)
    case requestFailed(error: Error?)
    case badRequest(error: Error?)
    case forbidden(error: Error?)
    case serverError(error: Error?)
    case redirected(error: Error?)
    case migration(error: Error?)
}

```
ÊØîÂ¶ÇËØ∑Ê±ÇÊàêÂäüÔºåÊàë‰ª¨‰ºöÈ¶ñÂÖàcheck https Êè°Êâãü§ùÊòØÂê¶ÊàêÂäüÔºå

ÈÄöËøáswitch ÊääerrorËøîÂõû

```
private func checkStatusCode(with urlResponse: HTTPURLResponse, error: Error?) -> NetworkResponseError? {
        switch urlResponse.statusCode {
        case 200 ... 299: return nil
        case 300 ... 399:
            return NetworkResponseError.redirected(error: error)
        case 403:
            return NetworkResponseError.forbidden(error: error)
        case 400 ... 499:
            return NetworkResponseError.badRequest(error: error)
        case 500 ... 509:
            return NetworkResponseError.serverError(error: error)
        default: return nil
        }
    }
```

Êàë‰ª¨ÂèØ‰ª•Ê≠£Â∏∏ÈÄöËøá `error?.localizedDescription` Ëé∑ÂèñÂà∞ÈîôËØØ‰ø°ÊÅØÔºåÊØîÂ¶ÇË∂ÖÊó∂ËØ∑ÈáçËØïÁ≠â
‰ΩÜÊòØÂæÄÂæÄÊàë‰ª¨ÂêéÂè∞Ê≤°ÊúâÂíåhttpÁªëÂÆöÔºåÊàë‰ª¨ÈúÄË¶ÅÂú®ÊàêÂäüÈìæÊé•ÂêéÔºåËøòÈúÄË¶Åcheck responseÈáåÈù¢ÁöÑ `code ` Âíå `message`

> // 200 but error in response

Ëøô‰∏™Êó∂ÂÄôÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá  `extension` `NetworkResponseError`  ÈáçÂÜô `LocalizedError ` ÁöÑ`errorDescription`Ôºå`code`

```
extension NetworkResponseError: LocalizedError {
    public var errorDescription: String? {
        switch self {
        case let .parsingError(error),
             let .requestFailed(error),
             let .badRequest(error),
             let .forbidden(error),
             let .serverError(error),
             let .redirected(error),
             let .migration(error):
            return error?.localizedDescription

        case let .error(error):
            return error.msg
        }
    }

    public var code: Int? {
        switch self {
        case let .error(error):
            return error.code
        default:
            return nil
            break
        }
    }
}
```

Âú®ÂõûË∞É‰∏≠Êàë‰ª¨ÂèØ‰ª• `print` log

`print(error?.localizedDescription ?? "no messages")`

`            if let error = error as? NetworkResponseError {
print(error.code)
}
`

‰ΩÜÂú®È°πÁõÆ‰∏≠‰ºöÊúâ‰∫õÈÄöÁî®ÁöÑerror Â§ÑÁêÜÔºåÊØîÂ¶Ç Âº∫Âà∂ÈÄÄÂá∫ÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáÂ±ûÊÄßÈó≠ÂåÖÊù•ÂØπÂÖ∂ÂÖ®Â±ÄÊìç‰Ωú

 ```
     private func handleSuccessResponse(with data: Data, and urlResponse: URLResponse?,
                                       with completion: @escaping (R?, URLResponse?, NetworkResponseError?) -> Void) {
        NetworkLayer.didFinishWithSuccess?()
        if let urlRes = urlResponse?.url {
            print("\n[NW]")
            print("\nReceived: " + urlRes.description)
        }

        do {
            if var responseObject = try? JSONDecoder().decode(ErrorMetaData.self, from: data) {
                // 200 but error in response
                if let code = responseObject.code {
                    if code == 0 || code == 200 {
                        if var result = try? JSONDecoder().decode(ResponseObject.self, from: data) {
                            print("[\nNW]")
                            print("[S] Reponse: \n" + ((convertToDict(result)?.description) ?? ""))
                            completion(result, urlResponse, nil)
                        }
                    } else {
                        print("\n[NW]\n")
                        print("[S] Error Response: code = " + "\(code)" + "  msg = " + (responseObject.msg ?? "nil"))
                        if (responseObject.msg?.isEmpty ?? false) || responseObject.msg == nil {
                            responseObject.msg = "service error, try again later"
                        }
                        NetworkLayer.didExecuteWithError?(NetworkResponseError.error(errorData: responseObject))
                        completion(nil, nil, NetworkResponseError.error(errorData: responseObject))
                    }
                }
            }
        } catch let error as Error {
            print("[NW]")
            print("JSONSerialization" + "\(error)")
            completion(nil, nil, NetworkResponseError.parsingError(error: error))
        }
    }
 ```
 
 Êàë‰ª¨Âú® `NetworkLayer` ÂÆö‰πâÂá†ÁßçÈó≠ÂåÖÂ±ûÊÄß
 
 ```
 public struct NetworkLayer {
    public static var forceLogoutAction: (() -> Void)?
    public static var didFinishWithSuccess: (() -> Void)?
    public static var didFinishWithError: ((_ error: Error?) -> Void)?
    public static var didExecuteWithError: ((_ error: Error?) -> Void)?
}
 ```
 Âú®appdelegate ‰∏≠call `setUpNetWorkLayer()`, ÈÄöËøáÈó≠ÂåÖÊù•Â§ÑÁêÜ
 
 ```
 extension AppDelegate {
    @objc func setUpNetWorkLayer() {
        NetworkLayer.forceLogoutAction = {
            ApplicationFlow.sharedInstance().doLogout()
        }

        NetworkLayer.didFinishWithSuccess = {

        }

        NetworkLayer.didFinishWithError = { error in
            print(error?.localizedDescription ?? "no messages")
        }

        NetworkLayer.didExecuteWithError = { error in
            if let error = error as? NetworkResponseError {
                print("error.localizedDescription" + "\(error.localizedDescription)")
                if let code = error.code {
                    if code == 401 || code == 501 { // logout
                        NetworkLayer.forceLogoutAction?()
                        return
                    }
                }
            }
        }
    }
}

 ```